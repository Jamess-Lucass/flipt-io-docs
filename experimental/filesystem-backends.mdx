---
title: Filesystem Backends
description: Details on the experimental filesystem backends for Flipt.
---

<Note>This feature was added in Flipt `v1.23.0`.</Note>

The following backend types are designed to support declarative management of feature flag state.
In particular, they're designed to support GitOps practices with minimal external dependencies.

This feature can be enabled via Flipts configuration parameters when running the `flipt` server binary.
As always, these parameters can be expressed via environment variables or Flipt's yaml configuration file:

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true
    ```

  </Tab>
</Tabs>

## Backend Types

There are currently two backend types we classify as being filesystem backends, `local` and `git`.
The `local` backend has been primarily developed to support a local development experience.
Whereas, the `git` backend is intended for production and serves flag state directly from a configurable repository and Git reference (e.g. branch).

### `local` type

The purpose of this backend type is to support serving Flipt flag state directly from your local filesystem.
You can simply specify a relative or absolute directory in order to start a local Flipt instance and serve flag state.
This is particularly useful for local development and validation of flag state changes.

Flipt will periodically rebuild its state from the local disk.

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    FLIPT_STORAGE_TYPE="local"
    FLIPT_STORAGE_LOCAL_PATH="."
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true

    storage:
      type: local
      local:
        path: "."
    ```

  </Tab>
</Tabs>

> Serve your current directory.

### `git` type

The `git` type backend is used to configure a target git repository and git reference to source feature flag state from.
The configuration contains fields for addressing the repository, configuring the target reference as well as adding authentication credentials.

Once a target repository and reference is configured, Flipt will poll the source repository on a periodic cadence.
This cadence is also configurable and defaults to 30 seconds.

Flipt will follow the configured reference (e.g. branch name) and keep up to date with new changes.

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    FLIPT_STORAGE_TYPE="git"
    FLIPT_STORAGE_GIT_REPOSITORY="https://github.com/predictab.le/config.git"
    FLIPT_STORAGE_GIT_REF="main"
    FLIPT_STORAGE_GIT_POLL_INTERVAL="30s"
    # for private repository access
    FLIPT_STORAGE_GIT_AUTHENTICATION_BASIC_USERNAME=...
    FLIPT_STORAGE_GIT_AUTHENTICATION_BASIC_PASSWORD=...
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true

    storage:
      type: git
      git:
        repository: "https://github.com/predictab.le/config.git"
        ref: "main"
        poll_interval: "30s"
        authentication:
          basic:
            username: ...
            password: ...
          token:
            access_token: ...
    ```

  </Tab>
</Tabs>

#### Authentication

The `git` type backend supports both `basic` and `token` based authentication schemes.
These sections are mutually exclusive. Flipt will fail to initialize with a validation error if you attempt to configure both.

<Note>
  GitHub PAT (Personal Access Tokens) should be supplied using `basic`
  authentication as the password. Use your GitHub username in the `username`
  field.
</Note>

## Flag State Configuration

Each of Flipts filesystem backends expects you to represent your feature flag configuration via a set of yaml files.
These files declaratively define what flags, segments, variants etc. exist and in what configuration.

### Locating Flag State

Flipts filesystem backends allow you to define feature flags alongside other configuration in a shared directory or repository.
In order to identify which files are intended for Flipt, it uses a naming scheme to index which are flag state files.
By default, Flipt will look for the following filename patterns when identifying files to attempt to parse as Flipt state:

- `**/features.yaml`
- `**/features.yml`
- `**/*.features.yaml`
- `**/*.features.yml`

Meaning, any file named `features.yaml`, `features.yml` or with either extension `.features.yaml` or `.features.yml` is considered.
This is recursively from the root of your target directory or repository.

If this naming convention does not work for you, for whatever reason, it can be overriden by creating a file named `.flipt.yml` in the root of your target directory tree.
This file will be used to instruct Flipt on how to index your directory tree and find flag state files:

```yaml
version: "1.0"
include:
  - "**/features.yaml"
  - "**/features.yml"
  - "**/*.features.yaml"
  - "**/*.features.yml"
exclude: []
```

The index file contains two lists `include` and `exclude`. These can contain specific paths or Glob matching patterns.
The indexing process first matches the `include` section and then filters that set by the `exclude` section.

### Defining Flag State

<Info>
  Flipt flag state file format has been taken directly from Flipts existing
  [import and export](/configuration/storage#import-export) flag state format.
  You can run `flipt export` and add / commit the result to a directory or git
  repository to get started quickly.
</Info>

```yaml features.yaml
namespace: backend
flags:
  - key: awesomeNewFeature
    name: Awesome New Feature
    enabled: true
    variants:
      - key: enabled
        name: Enabled
      - key: disabled
        name: Disabled
    rules:
      - segment: internal-users
        rank: 1
        distributions:
          - variant: enabled
            rollout: 100
      - segment: all-users
        rank: 2
        distributions:
          - variant: enabled
            rollout: 20
          - variant: disabled
            rollout: 80

segments:
  - key: internal-users
    name: Internal Users
    constraints:
      - type: STRING_COMPARISON_TYPE
        property: organization
        operator: eq
        value: internal
    match_type: ALL_MATCH_TYPE
  - key: all-users
    name: All Users
    match_type: ALL_MATCH_TYPE
```

Each file identified for use by Flipt represents the contents of a single namespace.
Multiple namespaces can be defined across multiple files.
You can organize these files how you like in your target directory.

<Tip>
  By defining different namespaces in different directories, you can leverage
  features such as GitHub's Codeowners. This gives you authorization mechanisms
  for managing contributions to Flipt state.
</Tip>

The file format currently consists of four top-level keys:

```yaml
version: "1.0" # a version for this file format
namespace: default # string identifying the resources collective namespace
flags: [] # [Flag] list of Flag definitions
segments: [] # [Segment] list of Segment definitions
```

#### Flags and Variants

<Info>
  All the resources in Flipt are explained in more depth in the
  [Concepts](/concepts) documentation page.
</Info>

The flags section is where your `Flag`, `Variant` and `Rule` definitions live.
A Flag has many variants and many rules.

```yaml
flags:
  - key: string
    name: string
    description: string
    enabled: bool
    variants: [] # [Variant] a list of variants
    rules: [] # [Rule] a list of rules
```

Variants belong to flags and they are nested within each flag definition in a list under the key `variants`.
A variant consists of a `key`, `name` and optional `description`.

```yaml
variants:
  - key: red
    name: Red
    description: The color red
```

#### Rules and Distributions

Rules also belong to Flags, however, they also reference specific Segments.
Their purpose is to declare the distribution of which variants are returned for a flag.
Rules require a matching segment key in order for the distribution to be considered.
Rules are ordered by `rank`, allowing you to configure multiple potential matches, first match wins.

For example, the following `rules` definition states that given a request matches the segment `newColorGroup` then it will return the variants `red` and `blue` in equal proportions (50/50 split).

```yaml
rules:
  - segment: newColorGroup
    rank: 1
    distributions:
      - variant: red
        rollout: 50
      - variant: blue
        rollout: 50
```

#### Segments and Constraints

Segments exist as a top-level key next to flags.
Their purpose is to provide classification of request contexts into different groups for matching on.
Segments are matched when their sets of constraints evaluate to `true`.
They can be re-used between different flags and their rule definitions.

```yaml
segments:
  - key: internal-users
    name: Internal Users
    constraints:
      - type: STRING_COMPARISON_TYPE
        property: organization
        operator: eq
        value: internal
    match_type: ALL_MATCH_TYPE
  - key: all-users
    name: All Users
    match_type: ALL_MATCH_TYPE
```

Here we have two segments `internal-users` and `all-users`.
The `internal-users` segment has a single constraint which matches the property `organization` found on a evaluation context with the string `internal`.
Given an evaluation API call is made with a context containing this property, the segment will match the request.

The `all-users` segment has no constraints and will match **all** requests.
This is useful because rules require a matching segment. This can be used as a catch all segment.

**Constraint Types**

Constraints have comparison types to identify what type is expected of a property and its target value.
These types dictate the kinds of `operator`, which can be performed on the target property and value.
There currently exist a few types of constraints:

- `STRING_COMPARISON_TYPE`
- `NUMBER_COMPARISON_TYPE`
- `BOOLEAN_COMPARISON_TYPE`
- `DATETIME_COMPARISON_TYPE`

**Match Types**

Each segment has a `match_type` which signifies whether or not the _all_ constraints have to match or _any_ (at-least one) must match.

- `ALL_MATCH_TYPE`
- `ANY_MATCH_TYPE`
